/*--------------- 1ra Area: Codigo de Usuario -----------------------*/
//-------> importaciones, paquetes

package gnz.backend.analizadores;

import gnz.backend.cuarteto.*;
import java_cup.runtime.*;
import gnz.backend.nodo.Nodo;
import gnz.backend.nodoExpresion.*;
import gnz.backend.nodoComparacion.*;
import gnz.backend.nodoDeclaracion.*;
import gnz.gui.frames.*;
import java.util.LinkedList;

parser code {:

    private EditorDeTextoFrame editor;
    private ManejadorDeDeclaraciones man;

    public parser(AnalizadorLexicoCodigo lex,EditorDeTextoFrame editor){
        super(lex);
        this.editor=editor;
    }

    //Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s){
        int columna = s.right+1;
        int linea = s.left+1;
        System.out.println("Error SINTACTICO:" + s.value + " en:" + linea + ":" + columna);
}

    //Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        int columna = s.right+1;
        int linea = s.left+1;
        System.out.println("Error SINTACTICO:" + s.value + " en:" + linea + ":" + columna);
 }

    public Cuarteto[] evaluarComparacionDeCiclo(Nodo n1,int ileft,int iright){
      //Label al inicio para que regrese
      String label = "L"+editor.getManTablas().obtenerNuevoNumeroDeLabel();
      Cuarteto inicioDeWhile=new Cuarteto("goto", null, null, label, TipoDeCuarteto.SOLO_ETIQUETA);
      editor.getManTablas().anadirCuarteto(inicioDeWhile);
      //Se analiza la expresion
      ManejadorDeDeclaraciones manejador = new ManejadorDeDeclaraciones(editor);
      Cuarteto[] cuartetos=manejador.evaluarExpresionDeCicloOCondicional(n1,ileft,iright);
      cuartetos[0]=inicioDeWhile;
      return cuartetos;
    }

:}

/*--------------- 2da Area: Declaraciones -----------------------*/

terminal String     PCOMA;
terminal String     ASIGNACION,COMA;
terminal String     IDENTIFICADOR;
terminal String     BOOLEAN;
terminal String     TRUE,FALSE;
terminal String     CHAR;
terminal String     DECLARACION_CARACTER;
terminal String     BYTE,INT,LONG,FLOAT,DOUBLE;
terminal String     NUMERO_ENTERO,NUMERO_DECIMAL,NUMERO_DECIMALF;
terminal String     STRING;
terminal String     DECLARACION_STRING;

terminal String     MAS,POR,MENOS,DIV,PORCENTAJE;
terminal String     MENOR,MAYOR,MENOR_IGUAL,MAYOR_IGUAL,DISTINTO_DE,IGUAL_A;
terminal String     NOT,AND,OR;

terminal String     PARENTESIS_ABIERTO,PARENTESIS_CERRADO,CORCHETE_ABIERTO,CORCHETE_CERRADO;

terminal String     IF,ELSIF,ELSE;

terminal String     WHILE,DO;

terminal String     FOR,DOS_PUNTOS;

terminal String     ARRAY;

terminal String     PRINT,PRINTLN,SCANS,SCANN;

terminal String     VOID,RETURN;

terminal String     MAIN;

terminal String     SEPARADOR;

//terminal String     COMENTARIO_LINEA,COMENTARIO_DE_BLOQUE;


non terminal Object     inicio;
non terminal Object     conjuntoDeInstrucciones;
non terminal Nodo       unaInstruccion;
non terminal LinkedList<Nodo>     conjuntoDeDeclaraciones;
non terminal Nodo     unaDeclaracion;


//******************************************************************Declaracion de variables******************************************

non terminal Nodo     declaracionDeVariables;
non terminal TipoDeVariable     tipoDeVariable;
non terminal LinkedList<Nodo>     conjuntoDeIdentificadoresParaVariables;
non terminal Nodo     unIdentificadorParaVariable;
non terminal Nodo     expresion;

//******************************************************************Condicion y comparacion******************************************

non terminal Nodo     comparacion;
non terminal Object     condicion;


//******************************************************************Asignacion de variables******************************************

non terminal Nodo     asignacionDeVariable;

//******************************************************************Declaracion de arreglos******************************************

non terminal NodoArregloDeclaracion     declaracionDeArreglos;
non terminal NodoId     unIdentificadorParaArreglo;
non terminal LinkedList<Nodo>     conjuntoDeDimensiones;
non terminal Nodo     unaDimension;
non terminal LinkedList<NodoId>     conjuntoDeIdentificadoresParaArreglo;
non terminal Nodo     asignacionDeArreglo;

//******************************************************************Declaracion de estructura If******************************************

non terminal Object     declaracionDeEstructuraIf;

//******************************************************************Declaracion de estructura IF-ELSE******************************************

non terminal Object     declaracionDeEstructuraIfElse;

//******************************************************************Declaracion de estructura ELSEIF******************************************

non terminal Object     declaracionDeEstructuraElseIf,conjuntoDeElseIf,unElseIf;


//******************************************************************DeclaracionCHAR de estructura While******************************************

non terminal Cuarteto[]     declaracionDeEstructuraWhile;
non terminal Object     instrucccionWhile;

//******************************************************************declaracion de estructura DoWhile********************************************

non terminal Object     declaracionDeEstructuraDoWhile;
non terminal Object     declaracionDo;

//******************************************************************declaracion de estructura For********************************************

non terminal Object     declaracionDeEstructuraFor,incrementoDecremento;
non terminal Object     asignacionParaFor;

//******************************************************************declaracion de funciones Predefinidas********************************************

non terminal Object     declaracionDeFuncionesPredefinidas;
non terminal Object     conjuntoDeTexto;
non terminal Object     unTexto;

//***********************************************************************************Subprogramas*****************************************************

non terminal Object     conjuntoDeSubprogramas;
non terminal Object     unSubPrograma;
non terminal Object     tipoDeRetorno;
non terminal Object     conjuntoDeParametros;
non terminal Object     unParametro;
non terminal Object     cuerpoDeFuncion,instruccionReturn;
non terminal Object     llamadaDeFuncion;
non terminal Object     listaDeParametros,miParametro;
//***********************************************************************************Funcion Main***************************************************
non terminal Object funcionMain;


/*--------------- 3ra Area: Reglas Semanticas -----------------------*/

precedence left ELSE;
precedence left ELSIF;
precedence left MAS, MENOS;
precedence left POR, DIV,PORCENTAJE;
precedence left OR;
precedence left AND;
precedence left NOT;

start with inicio;
//*******************************************************Expresiones,comparaciones y tipos de variables****************************
expresion::= expresion:n1 MAS:i expresion:n2{:RESULT= new NodoExpresion(OperacionAritmetica.MAS,n1,n2,ileft,iright);:};
expresion::= expresion:n1 MENOS:i expresion:n2{:RESULT= new NodoExpresion(OperacionAritmetica.MENOS,n1, n2,ileft,iright);:};
expresion::=expresion:n1 POR:i expresion:n2{:RESULT= new NodoExpresion(OperacionAritmetica.POR,n1,n2,ileft,iright);:};
expresion::=expresion:n1 DIV:i expresion:n2{:RESULT= new NodoExpresion(OperacionAritmetica.DIV,n1,n2,ileft,iright);:};
expresion::=expresion:n1 PORCENTAJE:i expresion:n2{:RESULT= new NodoExpresion(OperacionAritmetica.PORCENTAJE,n1,n2,ileft,iright);:};
expresion::=PARENTESIS_ABIERTO expresion:n1 PARENTESIS_CERRADO{:RESULT = n1;:};
expresion::=MENOS PARENTESIS_ABIERTO expresion PARENTESIS_CERRADO;

expresion::=IDENTIFICADOR:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.IDENTIFICADOR,i,ileft,iright);:};
expresion::=TRUE:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.TRUE,i,ileft,iright);:};
expresion::=FALSE:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.FALSE,i,ileft,iright);:};
expresion::=DECLARACION_CARACTER:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.DECLARACION_CARACTER,i,ileft,iright);:};
expresion::=NUMERO_ENTERO:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.NUMERO_ENTERO,i,ileft,iright);:};
expresion::=NUMERO_DECIMAL:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.NUMERO_DECIMAL,i,ileft,iright);:};
expresion::=NUMERO_DECIMALF:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.NUMERO_DECIMALF,i,ileft,iright);:};
expresion::=DECLARACION_STRING:i{:RESULT=new NodoHojaExpresion(TipoDeHoja.DECLARACION_STRING,i,ileft,iright);:};
expresion::=IDENTIFICADOR PARENTESIS_ABIERTO PARENTESIS_CERRADO;
expresion::=IDENTIFICADOR PARENTESIS_ABIERTO listaDeParametros PARENTESIS_CERRADO;
listaDeParametros::=listaDeParametros COMA miParametro | miParametro;
miParametro::=comparacion;

comparacion::= comparacion:n1 AND:i comparacion:n2{:RESULT = new NodoLogico(OperacionLogica.AND,n1,n2,ileft,iright);:};
comparacion::= comparacion:n1 OR:i comparacion:n2{:RESULT = new NodoLogico(OperacionLogica.OR,n1,n2,ileft,iright);:};
comparacion::= NOT comparacion:n1;
//comparacion::= PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO;
comparacion::=expresion:n1 MENOR:i expresion:n2{:RESULT= new NodoComparacion(OperacionComparacion.MENOR,n1,n2,ileft,iright);:};
comparacion::=expresion:n1 MAYOR:i expresion:n2{:RESULT= new NodoComparacion(OperacionComparacion.MAYOR,n1,n2,ileft,iright);:};
comparacion::=expresion:n1 MENOR_IGUAL:i expresion:n2{:RESULT= new NodoComparacion(OperacionComparacion.MENOR_IGUAL,n1,n2,ileft,iright);:};
comparacion::=expresion:n1 MAYOR_IGUAL:i expresion:n2{:RESULT= new NodoComparacion(OperacionComparacion.MAYOR_IGUAL,n1,n2,ileft,iright);:};
comparacion::=expresion:n1 DISTINTO_DE:i expresion:n2{:RESULT= new NodoComparacion(OperacionComparacion.DISTINTO_DE,n1,n2,ileft,iright);:};
comparacion::=expresion:n1 IGUAL_A:i expresion:n2{:RESULT= new NodoComparacion(OperacionComparacion.IGUAL_A,n1,n2,ileft,iright);:};
comparacion::=expresion:n1 {:RESULT=n1;:};

tipoDeVariable::=STRING{:RESULT=TipoDeVariable.STRING;:};
tipoDeVariable::=BOOLEAN{:RESULT=TipoDeVariable.BOOLEAN;:};
tipoDeVariable::=CHAR{:RESULT=TipoDeVariable.CHAR;:};
tipoDeVariable::=BYTE{:RESULT=TipoDeVariable.BYTE;:};
tipoDeVariable::=INT{:RESULT=TipoDeVariable.INT;:};
tipoDeVariable::=LONG{:RESULT=TipoDeVariable.LONG;:};
tipoDeVariable::=FLOAT{:RESULT=TipoDeVariable.FLOAT;:};
tipoDeVariable::=DOUBLE{:RESULT=TipoDeVariable.DOUBLE;:};
tipoDeVariable::=VOID{:RESULT=TipoDeVariable.VOID;:};


//******************************************************************Inicio**********************************************************

inicio::=conjuntoDeDeclaraciones
{::};
inicio::= conjuntoDeDeclaraciones:declaraciones conjuntoDeSubprogramas SEPARADOR funcionMain
{::};
inicio::= conjuntoDeDeclaraciones  SEPARADOR funcionMain;
inicio::= conjuntoDeSubprogramas  SEPARADOR funcionMain;
inicio::= SEPARADOR funcionMain;

conjuntoDeInstrucciones::=conjuntoDeInstrucciones unaInstruccion | unaInstruccion;

//******************************************************************Conjunto de declaraciones**********************************************************
conjuntoDeDeclaraciones::=conjuntoDeDeclaraciones:lista unaDeclaracion:n1
{:lista.add(n1);RESULT=lista;:}
 |
 unaDeclaracion:n1
 {:LinkedList<Nodo> lista = new LinkedList<>();
   lista.add(n1);
   RESULT=lista;
 :};
unaDeclaracion::=declaracionDeVariables:n1
          {:RESULT=n1;:};

unaDeclaracion::=asignacionDeVariable:n1
          {:RESULT=n1;:};

unaDeclaracion::=declaracionDeArreglos:n1
          {:RESULT=n1;:};
unaDeclaracion::=asignacionDeArreglo;

//******************************************************************Error**********************************************************

unaInstruccion::=error;

//******************************************************************Declaracion de variables****************************************************
unaInstruccion::=declaracionDeVariables;
declaracionDeVariables::=tipoDeVariable:tipo conjuntoDeIdentificadoresParaVariables:lista PCOMA
{:NodoDeclaracion n1 = new NodoDeclaracion(tipo,lista);
man = new ManejadorDeDeclaraciones( n1,editor);
RESULT=n1;
  :};
conjuntoDeIdentificadoresParaVariables::=
conjuntoDeIdentificadoresParaVariables:lista COMA unIdentificadorParaVariable:n1
{:lista.add(n1);RESULT = lista;:}
  |
unIdentificadorParaVariable:n1
{:LinkedList<Nodo> miLista = new LinkedList<>();
  miLista.add(n1);
  RESULT= miLista;
:};

unIdentificadorParaVariable::=IDENTIFICADOR:i {:RESULT= new NodoId(i,null,ileft,iright);:};
unIdentificadorParaVariable::=IDENTIFICADOR:i ASIGNACION comparacion:n1 {:RESULT= new NodoId(i,n1,ileft,iright);:};

//******************************************************************Asignacion de variables****************************************************
unaInstruccion::=asignacionDeVariable;
asignacionDeVariable::=IDENTIFICADOR:i ASIGNACION comparacion:n1 PCOMA
{:NodoId nodo = new NodoId(i,n1,ileft,iright);
  man = new ManejadorDeDeclaraciones( nodo,editor);
  RESULT=nodo;
  :};

//*******************************************************************Declaracion de arreglos********************************************
unaInstruccion::=declaracionDeArreglos:n1{:RESULT=n1;:};
declaracionDeArreglos::=ARRAY:i tipoDeVariable:tipo conjuntoDeDimensiones:dimensiones conjuntoDeIdentificadoresParaArreglo:listaIds PCOMA
{:
NodoArregloDeclaracion nodo = new NodoArregloDeclaracion( tipo, listaIds,dimensiones,ileft,iright);
man = new ManejadorDeDeclaraciones(nodo,editor);
RESULT=nodo;
:};
conjuntoDeDimensiones::=conjuntoDeDimensiones:lista unaDimension:n1
{:lista.add(n1);
  RESULT=lista;:}
|
unaDimension:n1
{:LinkedList<Nodo> lista = new LinkedList<>();
lista.add(n1);
RESULT = lista;
:};

unaDimension::=CORCHETE_ABIERTO comparacion:n1 CORCHETE_CERRADO{:RESULT = n1;:};

conjuntoDeIdentificadoresParaArreglo::=conjuntoDeIdentificadoresParaArreglo:lista COMA unIdentificadorParaArreglo:i
{:lista.add(i);
RESULT=lista;:}
 |
  unIdentificadorParaArreglo:n1
  {:LinkedList<NodoId> lista = new LinkedList<>();
    lista.add(n1);
    RESULT=lista;
    :};

unIdentificadorParaArreglo::=IDENTIFICADOR:i{:RESULT= new NodoId(i,null,ileft,iright);:};

//*******************************************************************Asignacion de arreglos********************************************
unaInstruccion::=asignacionDeArreglo:n1{:RESULT=n1;:};
asignacionDeArreglo::=IDENTIFICADOR:id conjuntoDeDimensiones:expresiones ASIGNACION comparacion:expresion PCOMA
{:NodoAsignacionArreglo n1 = new NodoAsignacionArreglo(id,expresiones,expresion,idleft,idright);
  man = new ManejadorDeDeclaraciones( n1,editor);
  RESULT=n1;
  :};

//*******************************************************************Instruccion IF ***************************************************
unaInstruccion::=declaracionDeEstructuraIf;
//------>1
declaracionDeEstructuraIf::= IF PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO unaInstruccion;
//------>2
declaracionDeEstructuraIf::= IF PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;
//*****************************************************************Instruccion IF-ELSE*****************************************************
unaInstruccion::=declaracionDeEstructuraIfElse;
//------->1
declaracionDeEstructuraIfElse::= declaracionDeEstructuraIf ELSE unaInstruccion;
//------->2
declaracionDeEstructuraIfElse::= declaracionDeEstructuraIf ELSE CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;
//****************************************************************Instruccion ELSEIF*******************************************************
unaInstruccion::=declaracionDeEstructuraElseIf;
//------->1
declaracionDeEstructuraElseIf::=declaracionDeEstructuraIf conjuntoDeElseIf;
//------->2
declaracionDeEstructuraElseIf::=declaracionDeEstructuraIf conjuntoDeElseIf ELSE unaInstruccion;
//------->3
declaracionDeEstructuraElseIf::=declaracionDeEstructuraIf conjuntoDeElseIf ELSE CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;

conjuntoDeElseIf::=conjuntoDeElseIf unElseIf|unElseIf;
unElseIf::=ELSIF PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO unaInstruccion;
unElseIf::=ELSIF PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;


//**********************************************************Instruccion While*************************************************************
unaInstruccion::=declaracionDeEstructuraWhile:cuartetos
{:
  if(cuartetos!=null){
    //Cuarteto que permite volver hacia arriba
    editor.getManTablas().anadirCuarteto(new Cuarteto("goto", null, null, cuartetos[0].getResultado(), TipoDeCuarteto.GOTOSALIDA));
    //Cuarteto que genera la etiqueta final
   editor.getManTablas().anadirCuarteto(new Cuarteto("goto", null, null, cuartetos[1].getResultado(), TipoDeCuarteto.SOLO_ETIQUETA));

  }
  :};

declaracionDeEstructuraWhile::= WHILE PARENTESIS_ABIERTO:i comparacion:n1 PARENTESIS_CERRADO
{:
  //Se crea la etiqueta que permitiria el ciclo
  String label = "L"+editor.getManTablas().obtenerNuevoNumeroDeLabel();
  Cuarteto inicioDeWhile=new Cuarteto("goto", null, null, label, TipoDeCuarteto.SOLO_ETIQUETA);
  editor.getManTablas().anadirCuarteto(inicioDeWhile);
  //Se analiza la expresion
  ManejadorDeDeclaraciones manejador = new ManejadorDeDeclaraciones(editor);
  Cuarteto[] cuartetos=manejador.evaluarExpresionDeCicloOCondicional(n1,ileft,iright);
  cuartetos[0]=inicioDeWhile;
  RESULT=cuartetos;:} unaInstruccion;

declaracionDeEstructuraWhile::= WHILE PARENTESIS_ABIERTO:i comparacion:n1 PARENTESIS_CERRADO
{:
  //Se crea la etiqueta que permitiria el ciclo
  String label = "L"+editor.getManTablas().obtenerNuevoNumeroDeLabel();
  Cuarteto inicioDeWhile=new Cuarteto("goto", null, null, label, TipoDeCuarteto.SOLO_ETIQUETA);
  editor.getManTablas().anadirCuarteto(inicioDeWhile);
  //Se analiza la expresion
  ManejadorDeDeclaraciones manejador = new ManejadorDeDeclaraciones(editor);
  Cuarteto[] cuartetos=manejador.evaluarExpresionDeCicloOCondicional(n1,ileft,iright);
  cuartetos[0]=inicioDeWhile;
  RESULT=cuartetos;
:} CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;

//*********************************************************Instruccion Do-While***********************************************************
unaInstruccion::=declaracionDeEstructuraDoWhile;
declaracionDeEstructuraDoWhile::= DO unaInstruccion WHILE PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO;
declaracionDeEstructuraDoWhile::= DO CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO WHILE PARENTESIS_ABIERTO comparacion PARENTESIS_CERRADO;
//*********************************************************Instruccion For*****************************************************************
unaInstruccion::=declaracionDeEstructuraFor;
declaracionDeEstructuraFor::=FOR PARENTESIS_ABIERTO asignacionParaFor DOS_PUNTOS comparacion DOS_PUNTOS incrementoDecremento PARENTESIS_CERRADO unaInstruccion;
declaracionDeEstructuraFor::=FOR PARENTESIS_ABIERTO asignacionParaFor DOS_PUNTOS comparacion DOS_PUNTOS incrementoDecremento PARENTESIS_CERRADO
                             CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;
asignacionParaFor::=IDENTIFICADOR ASIGNACION comparacion;
incrementoDecremento::= MAS NUMERO_ENTERO;
incrementoDecremento::= MENOS NUMERO_ENTERO;
//*********************************************************Funciones predefinidas************************************************************
unaInstruccion::=declaracionDeFuncionesPredefinidas;
declaracionDeFuncionesPredefinidas::= PRINTLN CORCHETE_ABIERTO conjuntoDeTexto CORCHETE_CERRADO PCOMA;
declaracionDeFuncionesPredefinidas::= PRINT CORCHETE_ABIERTO conjuntoDeTexto CORCHETE_CERRADO PCOMA;
declaracionDeFuncionesPredefinidas::= SCANS CORCHETE_ABIERTO IDENTIFICADOR CORCHETE_CERRADO PCOMA;
declaracionDeFuncionesPredefinidas::= SCANN CORCHETE_ABIERTO IDENTIFICADOR CORCHETE_CERRADO PCOMA;
conjuntoDeTexto::= conjuntoDeTexto COMA unTexto | unTexto;
unTexto::=expresion;

//************************************************************Return*************************************************************************
unaInstruccion::=instruccionReturn;
instruccionReturn::=RETURN comparacion PCOMA;

//************************************************************Llamada a funciones*************************************************************************
unaInstruccion::=llamadaDeFuncion;
llamadaDeFuncion::=IDENTIFICADOR PARENTESIS_ABIERTO conjuntoDeParametros PARENTESIS_CERRADO PCOMA;

//*********************************************************Subprogramas**********************************************************************

conjuntoDeSubprogramas::= conjuntoDeSubprogramas unSubPrograma| unSubPrograma;
unSubPrograma::=tipoDeVariable IDENTIFICADOR PARENTESIS_ABIERTO conjuntoDeParametros PARENTESIS_CERRADO
                CORCHETE_ABIERTO cuerpoDeFuncion CORCHETE_CERRADO;

unSubPrograma::=tipoDeVariable IDENTIFICADOR PARENTESIS_ABIERTO  PARENTESIS_CERRADO
                                CORCHETE_ABIERTO cuerpoDeFuncion CORCHETE_CERRADO;

conjuntoDeParametros::= conjuntoDeParametros COMA unParametro | unParametro;
unParametro::= tipoDeVariable IDENTIFICADOR;

cuerpoDeFuncion::=conjuntoDeDeclaraciones SEPARADOR conjuntoDeInstrucciones;
cuerpoDeFuncion::=conjuntoDeDeclaraciones SEPARADOR;
cuerpoDeFuncion::= SEPARADOR conjuntoDeInstrucciones;
cuerpoDeFuncion::= SEPARADOR;

//***************************************************************funcionMain************************************************************
funcionMain::= MAIN PARENTESIS_ABIERTO PARENTESIS_CERRADO CORCHETE_ABIERTO conjuntoDeInstrucciones CORCHETE_CERRADO;
